# 第二章 计算机组成

## 2.2 I/O端口和寻址

1. 统一编址

   ​	将I/O端口地址加入到存储器寻址空间中，像访问内存一样访问端口，也使用访问内存的指令。

2. 独立编址

   ​	将I/O端口独立编址，有自己独立的地址空间，有专门的指令。

   IBM PC机及其兼容机，主要使用独立编址，但也有使用统一编址的部分，比如说CGA显示卡的显示地址为内存空间的0xB800 - 0xBc00范围，所以要让一个字符显示在屏幕上，直接使用内存操作指令向上述地址写入数据即可。

## 2.3 BIOS

![1552212927738](第二章 计算机组成.assets\1552212927738.png)

​	对上述段落的解释：

**1.第一条指令的地址是什么？**

​	这个问题网上有两种解答，0xFFFFFFF0，0xFFFF0。当然第一种是对的，这个在[intel](https://www.baidu.com/s?wd=intel&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)手册第三卷第9章有详细说明，第一条指令的地址为0xFFFFFFF0。​	

![1552213089660](第二章 计算机组成.assets\1552213089660.png)

​	这个地址自从intel发布80386后就延续下来。

​	第二种地址在早年间也是对的，在intel还在使用16位cpu的时候，8086,[8088](https://www.baidu.com/s?wd=8088&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)，地址空间为1M，第一条指令的地址就是0xFFFF0了，回答这种地址的应该看的是早年的书，现在pc机已经不再使用了，下面是加电后寄存器的初始值。

![1552213185809](第二章 计算机组成.assets\1552213185809.png)

​	又或者是拿16位实模式说事，PC刚开机时确是16位实模式，这种模式的地址计算方式是使用CS和EIP寄存器中的值(Selector*16+EIP)，这么算下来确实是0xFFFF0。**但是**刚开机时并不是使用这种计算方式，虽然还在16位模式。但intel规定的是当CS中的初始值被改变后才使用这种一般的地址计算方式。未改变之前用Base+EIP来生成地址，所以还是0xFFFFFFF0。

![1552213372425](第二章 计算机组成.assets\1552213372425.png)

**2.第一条指令的地址为什么是0xFFFFFFF0?**

​	人为规定，历史遗留问题。

**3.BIOS代码块映射在什么位置？**

​	BIOS代码肯定是储存在EPROM中的，这时cpu如何访问？靠地址映射，硬件会把EPROM映射在两个地方，一个是从0xFFFFFFFF(4GB)处向下扩展，一个是从0xFFFFF(1MB)处向下扩展。第一个映射是因为第一条指令在0xFFFFFFF0，所以EPROM必须在那个位置。第二个映射是为了兼容，在16位时代就有了。

**4.第一条指令的内容是什么？**

​	这个也是比较容易混乱的地方，大多数人说第一条指令是个长跳转(long jmp)，跳转到0-0xFFFFF(0~1MB)这一段，然后再执行BIOS剩余的指令。然而又有一部分人看到intel手册第3卷的9.1.4节有这么一段话

![1552213584322](第二章 计算机组成.assets\1552213584322.png)

​	这里又说不让有长跳转。其实两种都对，intel手册上说的是让BIOS在高地址空间运行，期间一直不修改CS寄存器，也就一直使用Base+EIP的方式生成地址，这种新式做法应该是UEFI的那种刚开始就长跳转的属于老式做法，在qemu中导出的第一条汇编指令是这个样子0xfffffff0:  ljmp   \$0xf000 , \$0xe05b。

